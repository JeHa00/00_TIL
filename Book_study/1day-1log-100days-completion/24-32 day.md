# 0. Introduction

> [24 day](#24-day)
> [25 day](#25-day)
> [26 day](#26-day)
> [27 day](#27-day)
> [28 day](#28-day)
> [29 day](#29-day)
> [30 day](#30-day)
> [31 day](#31-day)
> [32 day:summary](#32-day-summary)


- IT 분야의 문해력을 기르기 위해서 꾸준히 매일 작은 지식들을 학습하고자 [1일 1로그 100일 완성 IT지식](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966263301&orderClick=LEa&Kc=)을 시작한다. 


- 소챕터의 요약 부분까지 읽으면 정리하여 올린다.

<br>

---
# 24 day

> **_subject: 알고리즘은 이상, 프로그램은 현실_**    
> **_summary:알고리즘이 청사진이면 프로그램은 건물이다._**

알고리즘은 추상적이괴, 이상적인 절차를 기술한 것으로, 구현에 필요한 세부사항과 현실적인 고려 사항을 무시한다. 

프로그램은 실제 컴퓨터가 문제를 해결 및 완료하기 위해 수행해야 하는 모든 단계를 구체적으로 서술한다.  

그래서 알고리즘은 이상적인 것이고, 프로그램은 실재하는 것이다. 

그래서 하나 이상의 알고리즘이 컴퓨터가 직접 처리할 수 있도록 표현된 것을 프로그램이라 볼 수 있다. 

이번 주제에서는 실제 프로그래밍에서 무슨 일이 일어나는지 자세히 설명하려고 한다.  

<br>

---
# 25 day

> **_subject: 다른 프로그램을 처리하기 위한 프로그램_**    
> **_summary: 프로그래밍에서 명령어를 만들고, 변수를 사용할 수 있을 때 사용한 언어를 어셈블리 언어라 한다._**  

프로그래밍에서 명령어를 만들고, 변수를 사용할 수 있을 때 '다른 프로그램을 처리하기 위한 프로그램'으로서 **어셈블러** 가 존재했다. 

그리고, 이 어셈블러를 작성할 때 사용한 언어를 **어셈블리 언어** 라 한다.  

프로그래머가 명령어를 추가하거나, 삭제할 때 변경 기록을 직접 관리하는 대신, 어셈블러가 각 명령어와 데이터 값이 메모리상 어느 위치에 있을지 파악해주기 때문이다.

<br>

---
# 26 day

> **_subject: 고수준 언어에서 프로그램 실행까지_**    
> **_summary:고수준 프로그래밍 언어의 개발_**

특정 프로세서 아키텍처에 독립적인 고수준 프로그래밍 언어(high-level programming language)가 개발되면서, 사람의 사고에 더 가까워 배우기 쉽고, 사용하기가 쉬워지고 여러 아키텍처상에서 실행될 수 있다. 

한 번 짜 놓으면 다양한 컴퓨터에서 실행할 수 있다. 

또한, 단순히 구문 오류 이외의 에러는 검출하기가 힘든 어셈블리 언어와는 달리 컴파일 단계에서 철자 오류, 구문 오류, 정의되지 않은 변수 같은 오류들을 확인할 수 있다. 

초창기 컴퓨터가 비싸고, 느리고, 성능에도 한계가 있어서 고수준 프로그래밍 언어는 비효율적이란 우려가 있었지만, 컴파일러 개발자들이 좋은 코드를 생성하고자 노력하여, 확립하는데 큰 도움이 되었다. 

<br>

---
# 27 day

> **_subject: 작문과 비슷한 프로그래밍_**    
> **_summary: 프로그래밍은 작문과 비슷하여, 유사한 고려사항들이 많다._**

프로그래밍은 작문과 비슷하다. 그래서 가독성이 중요하다. 

그리고, 프로그래밍 언어에 따라 사고 방식과 범위가 결정된다.

<br>

---
# 28 day

> **_subject:_구글 같은 서비스는 어떻게 개발할까?**    
> **_summary:큰 규모의 소프트웨어를 개발하기 위해서는 프로그래머, 테스트 담당자, 문서 담당자로 이뤄진 팀이 여러개 필요하는데, 그만큼 복잡하기 때문이다._**

큰 규모의 소프트웨어는 프로그래머, 테스트 담당자, 문서 담당자로 이뤄진 여러 개의 팀에 의해서 작성된다. 

왜 그럴까? 그만큼 복잡하기 때문이다. 

복잡하도록 만든 원인에는 무엇이 있는지 알아보자. 

규모가 클수록 많은 종류의 라이브러리와, 더 큰 규모의 API가 필요하다. 

또한, 그만큼 소프트웨어가 크기 때문에 많은 종류의 버그가 발생한다. 

그리고, 업데이트가 더 잦을 것이다.

마지막으로 개발 고객 환경이 자주 변하는 것도 더 복잡하도록 만드는 원인이다. 



그리고, 여러 함수로 이뤄진 라이브러리와 여러 라이브러리로 구성된 API 가 필요하다. 
큰 규모의 소프트웨어일수록 여러 종류의 버그가 발생하며, 

<br>

---
# 29 day

> **_subject:_**    
> **_summary:_**

<br>

---
# 30 day

> **_subject:_**    
> **_summary:_**

<br>

---
# 31 day

> **_subject:_**    
> **_summary:_**

<br>

---
# 32 day: summary

<br>

---
# Reference

- [1일 1로그 100일 완성 IT지식](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966263301&orderClick=LEa&Kc=) 