# 0. Introduction

> 1. [주소 바인딩](#1-주소-바인딩)
> 2. [메모리 관리와 관련된 용어](#2-메모리-관리와-관련된-용어)
> 3. [물리적 메모리의 할당 방식](#3-물리적-메모리의-할당-방식)
> 4. [페이징 기법](#4-페이징-기법)
> 5. [세그먼테이션](#5-세그먼테이션)
> 6. [페이지드 세그먼테이션](#6-페이지드-세그먼테이션)

<br>

- 해당 내용은 [운영체제와 정보기술의 원리 -반효경 지음-](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=) 와 [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)를 보고 정리한 내용이다.
- 정확하지 않은 내용이 있다면 말씀해주시면 감사하겠습니다.

<br>

---

# 1. 주소(address) 바인딩

<br>

## 1.1 주소란??

> - 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자

- **Memory는 주소를 통해 접근하는 저장장치다.**
- **컴퓨터 시스템은 32bit 혹은 64bit의 주소체계를 사용하는데,**
  - 32bit는 2^(32) 가지, 64bit는 2^(64) 가지의 서로 다른 메모리 위치를 구분할 수 있다.
- **byte 단위로 메모리 주소를 부여한다.**
- **집 주소가 행정구역을 통해 계층적으로 관리하는 것처럼 컴퓨터 상의 주소도 page를 통해 계층적으로 관리한다.**

<br>

## 1.2 논리적 주소, 물리적 주소

- **논리적 주소(logical address)란?**

  - program이 실행을 위해 메모리에 적재되면 process를 위해 생성되는 독자적인 공간
  - 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

- **물리적 주소(physical address)란?**

  - 물리적 메모리에 실제로 올라가는 위치
  - 물리적 주소의 낮은 주소 영역에는 OS가 올라간다.
  - 물리적 주소의 높은 주소 영역에는 user process들이 올라간다.

- **프로세스가 실행되기 위해서**
  - 해당 프로그램이 물리적 메모리에 올라가 있어야 한다.
  - 해당 논리적 주소가 물리적 메모리의 어느 위치에 매핑되는지 확인해야 한다.

<br>

## 1.3 주소 바인딩(address binding)

> logical address를 physical address로 연결시켜주는 작업

- **주소 바인딩 방식 3가지**: 물리적 메모리 주소가 결정되는 시기에 따라 분류된다.

  - 컴파일 타임 바인딩(compile time binding)
  - 로드 타임 바인딩(load time binding)
  - 실행시간 바인딩(execution time binding or run time binding)

    | 방식 이름 | compile time binding | load time binding | run time binding |
    | 시기 | 프로그램을 컴파일할 때 | 프로그램 실행이 시작될 때 | 프로그램 실행 시작 후 |

- **Compile time binding**

  - program이 올라가 있는 물리적 메모리의 위치를 변경하고 싶으면 컴파일을 다시 해야 한다.
  - 현대의 시분할 컴퓨터 환경에서는 잘 사용하지 않는 기법

- **Load time binding**

  - 로더(loader)의 책임 하에 프로그램이 종료될 때까지 물리적 메모리의 위치가 고정된다.
  - Loader: user program을 memory에 적재시키는 프로그램

- **Run time binding**
  - 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 방식
  - CPU가 주소 참조 시, address mapping table을 이용해 원하는 데이터가 물리적 메모리의 어느 위치에 존재하는지 확인한다.
  - `MMU(Memory Management Unit)` 라는 하드웨어적 지원이 필요

<br>

## 1.4 MMU 기법

> 기준 레지스터를 사용하여 가상 메모리를 물리적 메모리로 변환하는 방법

- **가정**

  - 프로그램의 주소 공간이 메모리의 한 장소에 연속적으로 적재되는 걸 가정한다.

- **기준 레지스터는**
  - **_재배치 레지스터(relocation register)_**라고도 부른다.
  - CPU가 사용하려는 프로세스의 물리적 메모리 시작 주소를 가지고 있다.

- **예시**
  - CPU가 논리적 주소: 123번지 정보를 요청  
  - 기준 레지스터(=재배치 레지스터): 23000  
  - 물리적 주소 = 123 + 23000 = 23123  
  - 물리적 주소 23123번지에서 CPU가 요청한 정보를 찾는다.  
  - 논리적 주소란 기준 레지스터로부터 얼마나 떨어져 있는지를 나타내는 것  

- **동일한 논리적 주소**
  - 프로세스는 각 자신만의 고유한 주소 공간을 가진다.  
  - 그래서 동일한 논리적 주소라고 할 지라도, 서로 다른 내용을 담는다.  
  -  _MMU 기법에서 프로세스가 바뀔 때마다 기준 레지스터의 값을 바뀌는 프로세스에 해당되는 값으로 재설정한다._  

- **메모리 보안**
  - 가상 메모리에 기준 레지스터를 더했을 때, 해당 프로세스의 주소 공간을 벗어나는 경우,   
    - 다른 프로세스 영역에 침범하거나, kernel 영역을 변경해 치명적인 결과를 초래할 수 있다.  
  - 이를 방지하고자, **_한계 레지스터(limit register)_** 를 사용하여, 프로세스 자신의 주소 공간을 넘어서는 메모리 참조를 하는지 확인한다.    

<br>

---

# 2. 메모리 관리와 관련된 용어

<br>

## 2.1 동적 로딩(Dynamic loading)

<br>

## 2.2 동적 연결(Dynamic linking))

<br>

## 2.3 중첩(overlays)

<br>

## 2.4 스와핑(Swapping)

<br>

---

# 3. 물리적 메모리의 할당 방식

<br>

## 3.1 연속할당 방식

<br>

### 3.1.1 고정분할 방식

<br>

### 3.1.2 가변분할 방식

<br>

## 3.2 불연속할당 기법

<br>

---

# 4. 페이징 기법

<br>

## 4.1 주소 변환 기법

<br>

## 4.2 페이지 테이블의 구현

<br>

## 4.3 계층적 페이징

<br>

## 4.4 역페이지 테이블

<br>

## 4.5 공유 페이지

<br>

## 4.6 메모리 보호

<br>

---

# 5. 세그먼테이션

<br>

---

# 6. 페이지드 세그먼테이션

<br>

---

<br>

---

# Reference

- [운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589&orderClick=LAG&Kc=)
- [kocw 이화여자대학교 운영체제 - 반효경 교수 -](http://www.kocw.net/home/cview.do?lid=3dd1117c48123b8e)
